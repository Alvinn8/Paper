From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Thu, 2 Apr 2020 02:37:57 -0400
Subject: [PATCH] Optimize Collision to not load chunks

The collision code takes an AABB and generates a cuboid of checks rather
than a cylinder, so at high velocity this can generate a lot of chunk checks.

Treat an unloaded chunk as a collision for entities, and also for players if
the "prevent moving into unloaded chunks" setting is enabled.

If that serting is not enabled, collisions will be ignored for players, since
movement will load only the chunk the player enters anyways and avoids loading
massive amounts of surrounding chunks due to large AABB lookups.

diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 30c4fadb244b6e44d6095faf18cff5cebce8349c..7d5c198059749a37807e209540f6c318b303cdf8 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -62,6 +62,7 @@ import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.level.ServerPlayerGameMode;
+import net.minecraft.server.level.TicketType;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
 import net.minecraft.server.network.ServerLoginPacketListenerImpl;
 import net.minecraft.sounds.SoundEvents;
@@ -74,6 +75,7 @@ import net.minecraft.util.Mth;
 import net.minecraft.world.effect.MobEffectInstance;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.GameType;
 import net.minecraft.world.level.Level;
@@ -808,6 +810,7 @@ public abstract class PlayerList {
         entityplayer1.forceSetPositionRotation(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch());
         // CraftBukkit end
 
+        worldserver1.getChunkSource().addRegionTicket(TicketType.POST_TELEPORT, new ChunkPos(location.getBlockX() >> 4, location.getBlockZ() >> 4), 1, entityplayer.getId()); // Paper
         while (avoidSuffocation && !worldserver1.noCollision(entityplayer1) && entityplayer1.getY() < 256.0D) {
             entityplayer1.setPos(entityplayer1.getX(), entityplayer1.getY() + 1.0D, entityplayer1.getZ());
         }
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 42a9a66b87d1d8c77c0448af971077c4fbdbd56c..509e38b19da6fe6717f6b9c3a8c214406cd8a9ea 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -171,7 +171,7 @@ public abstract class Entity implements Nameable, CommandSource, KeyedObject { /
     private CraftEntity bukkitEntity;
 
     public ChunkMap.TrackedEntity tracker; // Paper
-    boolean collisionLoadChunks = false; // Paper
+    public boolean collisionLoadChunks = false; // Paper
     public Throwable addedToWorldStack; // Paper - entity debug
     public CraftEntity getBukkitEntity() {
         if (bukkitEntity == null) {
diff --git a/src/main/java/net/minecraft/world/level/CollisionGetter.java b/src/main/java/net/minecraft/world/level/CollisionGetter.java
index 96165c2d308467c6e19703304e812d9069f12284..6f6219d871e625877e3b29d48909509b80cf32bf 100644
--- a/src/main/java/net/minecraft/world/level/CollisionGetter.java
+++ b/src/main/java/net/minecraft/world/level/CollisionGetter.java
@@ -51,8 +51,13 @@ public interface CollisionGetter extends BlockGetter {
         });
     }
 
-    default boolean noCollision(@Nullable Entity entity, AABB aABB, Predicate<Entity> predicate) {
-        return this.getCollisions(entity, aABB, predicate).allMatch(VoxelShape::isEmpty);
+    default boolean noCollision(@Nullable Entity entity, AABB axisalignedbb, Predicate<Entity> predicate){
+        try {
+            if (entity != null) entity.collisionLoadChunks = true; // Paper
+            return this.getCollisions(entity, axisalignedbb, predicate).allMatch(VoxelShape::isEmpty);
+        } finally {
+            if (entity != null) entity.collisionLoadChunks = false;
+        } // Paper
     }
 
     Stream<VoxelShape> getEntityCollisions(@Nullable Entity entity, AABB aABB, Predicate<Entity> predicate);
diff --git a/src/main/java/net/minecraft/world/level/CollisionSpliterator.java b/src/main/java/net/minecraft/world/level/CollisionSpliterator.java
index 56e7457787fff7b77f73a12740c2c15e6311d7fc..f6857326cdc56a6b6ff76d4ecd7c220ba2002547 100644
--- a/src/main/java/net/minecraft/world/level/CollisionSpliterator.java
+++ b/src/main/java/net/minecraft/world/level/CollisionSpliterator.java
@@ -7,6 +7,9 @@ import java.util.function.Consumer;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Cursor3D;
+import net.minecraft.server.MCUtil;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.level.WorldGenRegion;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.block.Blocks;
@@ -20,13 +23,13 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 
 public class CollisionSpliterator extends AbstractSpliterator<VoxelShape> {
     @Nullable
-    private final Entity source;
+    private final Entity source; final Entity getEntity() { return this.source; } // Paper - OBFHELPER
     private final AABB box;
     private final CollisionContext context;
     private final Cursor3D cursor;
-    private final BlockPos.MutableBlockPos pos;
+    private final BlockPos.MutableBlockPos pos; final BlockPos.MutableBlockPos getMutablePos() { return this.pos; } // Paper - OBFHELPER
     private final VoxelShape entityShape;
-    private final CollisionGetter collisionGetter;
+    private final CollisionGetter collisionGetter; final CollisionGetter getCollisionAccess() { return this.collisionGetter; } // Paper - OBFHELPER
     private boolean needsBorderCheck;
     private final BiPredicate<BlockState, BlockPos> predicate;
 
@@ -62,21 +65,37 @@ public class CollisionSpliterator extends AbstractSpliterator<VoxelShape> {
     boolean collisionCheck(Consumer<? super VoxelShape> consumer) {
         while(true) {
             if (this.cursor.advance()) {
-                int i = this.cursor.nextX();
-                int j = this.cursor.nextY();
-                int k = this.cursor.nextZ();
+                int i = this.cursor.nextX(); final int x = i;
+                int j = this.cursor.nextY(); final int y = j;
+                int k = this.cursor.nextZ(); final int z = k;
                 int l = this.cursor.getNextType();
                 if (l == 3) {
                     continue;
                 }
 
-                BlockGetter blockGetter = this.getChunk(i, k);
-                if (blockGetter == null) {
+                // Paper start - ensure we don't load chunks
+                Entity entity = this.getEntity();
+                BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getMutablePos();
+                boolean far = entity != null && MCUtil.distanceSq(entity.getX(), y, entity.getZ(), x, y, z) > 14;
+                blockposition_mutableblockposition.setValues(x, y, z);
+
+                boolean isRegionLimited = this.getCollisionAccess() instanceof WorldGenRegion;
+                BlockState blockState = isRegionLimited ? Blocks.VOID_AIR.defaultBlockState() : ((!far && entity instanceof ServerPlayer) || (entity != null && entity.collisionLoadChunks)
+                    ? this.getCollisionAccess().getBlockState(blockposition_mutableblockposition)
+                    : this.getCollisionAccess().getTypeIfLoaded(blockposition_mutableblockposition)
+                );
+
+                if (blockState == null) {
+                    if (!(entity instanceof ServerPlayer) || entity.level.paperConfig.preventMovingIntoUnloadedChunks) {
+                        VoxelShape voxelshape3 = Shapes.of(far ? entity.getBoundingBox() : new AABB(new BlockPos(x, y, z)));
+                        consumer.accept(voxelshape3);
+                        return true;
+                    }
                     continue;
                 }
+                // Paper - moved up
+                // Paper end
 
-                this.pos.set(i, j, k);
-                BlockState blockState = blockGetter.getBlockState(this.pos);
                 if (!this.predicate.test(blockState, this.pos) || l == 1 && !blockState.hasLargeCollisionShape() || l == 2 && !blockState.is(Blocks.MOVING_PISTON)) {
                     continue;
                 }
diff --git a/src/main/java/net/minecraft/world/phys/shapes/Shapes.java b/src/main/java/net/minecraft/world/phys/shapes/Shapes.java
index b7a9ad107c887274b593d5e14e5a8d48ccba9774..457732579c10acd478241f818a21c37f4066fdd7 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/Shapes.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/Shapes.java
@@ -235,7 +235,8 @@ public final class Shapes {
 
                             if (s < 3) {
                                 mutableBlockPos.set(axisCycle, q, r, p);
-                                BlockState blockState = world.getBlockState(mutableBlockPos);
+                                BlockState blockState = world.getTypeIfLoaded(mutableBlockPos); // Paper
+                                if (mutableBlockPos == null) return 0.0D; // Paper
                                 if ((s != 1 || blockState.hasLargeCollisionShape()) && (s != 2 || blockState.is(Blocks.MOVING_PISTON))) {
                                     initial = blockState.getCollisionShape(world, mutableBlockPos, context).collide(axis3, box.move((double)(-mutableBlockPos.getX()), (double)(-mutableBlockPos.getY()), (double)(-mutableBlockPos.getZ())), initial);
                                     if (Math.abs(initial) < 1.0E-7D) {
