From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Thu, 2 Apr 2020 02:37:57 -0400
Subject: [PATCH] Optimize Collision to not load chunks

The collision code takes an AABB and generates a cuboid of checks rather
than a cylinder, so at high velocity this can generate a lot of chunk checks.

Treat an unloaded chunk as a collision for entities, and also for players if
the "prevent moving into unloaded chunks" setting is enabled.

If that serting is not enabled, collisions will be ignored for players, since
movement will load only the chunk the player enters anyways and avoids loading
massive amounts of surrounding chunks due to large AABB lookups.

diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index ad9c0116f17f9dd9a45617ca724dee19cb0b0d0b..07f8a89e4fa9236338c3145d423599618d14e24a 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -62,6 +62,7 @@ import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.level.ServerPlayerGameMode;
+import net.minecraft.server.level.TicketType;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
 import net.minecraft.server.network.ServerLoginPacketListenerImpl;
 import net.minecraft.sounds.SoundEvents;
@@ -74,6 +75,7 @@ import net.minecraft.util.Mth;
 import net.minecraft.world.effect.MobEffectInstance;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.GameType;
 import net.minecraft.world.level.Level;
@@ -808,6 +810,7 @@ public abstract class PlayerList {
         entityplayer1.forceSetPositionRotation(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch());
         // CraftBukkit end
 
+        worldserver1.getChunkSource().addRegionTicket(TicketType.POST_TELEPORT, new ChunkPos(location.getBlockX() >> 4, location.getBlockZ() >> 4), 1, entityplayer.getId()); // Paper
         while (avoidSuffocation && !worldserver1.noCollision(entityplayer1) && entityplayer1.getY() < 256.0D) {
             entityplayer1.setPos(entityplayer1.getX(), entityplayer1.getY() + 1.0D, entityplayer1.getZ());
         }
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 73c4f198acd209e6db036165b53f181f3ae04aa7..dec239049842af43cb126ff0ca36e7319dbf5c5b 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -171,6 +171,7 @@ public abstract class Entity implements Nameable, CommandSource, KeyedObject { /
     private CraftEntity bukkitEntity;
 
     ChunkMap.TrackedEntity tracker; // Paper
+    boolean collisionLoadChunks = false; // Paper
     Throwable addedToWorldStack; // Paper - entity debug
     public CraftEntity getBukkitEntity() {
         if (bukkitEntity == null) {
diff --git a/src/main/java/net/minecraft/world/level/CollisionGetter.java b/src/main/java/net/minecraft/world/level/CollisionGetter.java
index 96165c2d308467c6e19703304e812d9069f12284..6f6219d871e625877e3b29d48909509b80cf32bf 100644
--- a/src/main/java/net/minecraft/world/level/CollisionGetter.java
+++ b/src/main/java/net/minecraft/world/level/CollisionGetter.java
@@ -51,8 +51,13 @@ public interface CollisionGetter extends BlockGetter {
         });
     }
 
-    default boolean noCollision(@Nullable Entity entity, AABB aABB, Predicate<Entity> predicate) {
-        return this.getCollisions(entity, aABB, predicate).allMatch(VoxelShape::isEmpty);
+    default boolean noCollision(@Nullable Entity entity, AABB axisalignedbb, Predicate<Entity> predicate){
+        try {
+            if (entity != null) entity.collisionLoadChunks = true; // Paper
+            return this.getCollisions(entity, axisalignedbb, predicate).allMatch(VoxelShape::isEmpty);
+        } finally {
+            if (entity != null) entity.collisionLoadChunks = false;
+        } // Paper
     }
 
     Stream<VoxelShape> getEntityCollisions(@Nullable Entity entity, AABB aABB, Predicate<Entity> predicate);
diff --git a/src/main/java/net/minecraft/world/level/CollisionSpliterator.java b/src/main/java/net/minecraft/world/level/CollisionSpliterator.java
index 56e7457787fff7b77f73a12740c2c15e6311d7fc..f6857326cdc56a6b6ff76d4ecd7c220ba2002547 100644
--- a/src/main/java/net/minecraft/world/level/CollisionSpliterator.java
+++ b/src/main/java/net/minecraft/world/level/CollisionSpliterator.java
@@ -7,6 +7,9 @@ import java.util.function.Consumer;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Cursor3D;
+import net.minecraft.server.MCUtil;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.level.WorldGenRegion;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.block.Blocks;
@@ -20,13 +23,13 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 
 public class CollisionSpliterator extends AbstractSpliterator<VoxelShape> {
     @Nullable
-    private final Entity source;
+    private final Entity source; final Entity getEntity() { return this.source; } // Paper - OBFHELPER
     private final AABB box;
     private final CollisionContext context;
     private final Cursor3D cursor;
-    private final BlockPos.MutableBlockPos pos;
+    private final BlockPos.MutableBlockPos pos; final BlockPos.MutableBlockPos getMutablePos() { return this.pos; } // Paper - OBFHELPER
     private final VoxelShape entityShape;
-    private final CollisionGetter collisionGetter;
+    private final CollisionGetter collisionGetter; final CollisionGetter getCollisionAccess() { return this.collisionGetter; } // Paper - OBFHELPER
     private boolean needsBorderCheck;
     private final BiPredicate<BlockState, BlockPos> predicate;
 
@@ -62,21 +65,37 @@ public class CollisionSpliterator extends AbstractSpliterator<VoxelShape> {
     boolean collisionCheck(Consumer<? super VoxelShape> consumer) {
         while(true) {
             if (this.cursor.advance()) {
-                int i = this.cursor.nextX();
-                int j = this.cursor.nextY();
-                int k = this.cursor.nextZ();
+                int i = this.cursor.nextX(); final int x = i;
+                int j = this.cursor.nextY(); final int y = j;
+                int k = this.cursor.nextZ(); final int z = k;
                 int l = this.cursor.getNextType();
                 if (l == 3) {
                     continue;
                 }
 
-                BlockGetter blockGetter = this.getChunk(i, k);
-                if (blockGetter == null) {
+                // Paper start - ensure we don't load chunks
+                Entity entity = this.getEntity();
+                BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getMutablePos();
+                boolean far = entity != null && MCUtil.distanceSq(entity.getX(), y, entity.getZ(), x, y, z) > 14;
+                blockposition_mutableblockposition.setValues(x, y, z);
+
+                boolean isRegionLimited = this.getCollisionAccess() instanceof WorldGenRegion;
+                BlockState blockState = isRegionLimited ? Blocks.VOID_AIR.defaultBlockState() : ((!far && entity instanceof ServerPlayer) || (entity != null && entity.collisionLoadChunks)
+                    ? this.getCollisionAccess().getBlockState(blockposition_mutableblockposition)
+                    : this.getCollisionAccess().getTypeIfLoaded(blockposition_mutableblockposition)
+                );
+
+                if (blockState == null) {
+                    if (!(entity instanceof ServerPlayer) || entity.level.paperConfig.preventMovingIntoUnloadedChunks) {
+                        VoxelShape voxelshape3 = Shapes.of(far ? entity.getBoundingBox() : new AABB(new BlockPos(x, y, z)));
+                        consumer.accept(voxelshape3);
+                        return true;
+                    }
                     continue;
                 }
+                // Paper - moved up
+                // Paper end
 
-                this.pos.set(i, j, k);
-                BlockState blockState = blockGetter.getBlockState(this.pos);
                 if (!this.predicate.test(blockState, this.pos) || l == 1 && !blockState.hasLargeCollisionShape() || l == 2 && !blockState.is(Blocks.MOVING_PISTON)) {
                     continue;
                 }
diff --git a/src/main/java/net/minecraft/world/phys/shapes/Shapes.java b/src/main/java/net/minecraft/world/phys/shapes/Shapes.java
index 2ffc69967b4ad30ed842583b2b3f47a8879d8ebb..cf5bce5be1049d30b5c59ecf7abb172597b8625f 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/Shapes.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/Shapes.java
@@ -236,7 +236,8 @@ public final class Shapes {
 
                             if (s < 3) {
                                 mutableBlockPos.set(axisCycle, q, r, p);
-                                BlockState blockState = world.getBlockState(mutableBlockPos);
+                                BlockState blockState = world.getTypeIfLoaded(mutableBlockPos); // Paper
+                                if (mutableBlockPos == null) return 0.0D; // Paper
                                 if ((s != 1 || blockState.hasLargeCollisionShape()) && (s != 2 || blockState.is(Blocks.MOVING_PISTON))) {
                                     initial = blockState.getCollisionShape(world, mutableBlockPos, context).collide(axis3, box.move((double)(-mutableBlockPos.getX()), (double)(-mutableBlockPos.getY()), (double)(-mutableBlockPos.getZ())), initial);
                                     if (Math.abs(initial) < 1.0E-7D) {
