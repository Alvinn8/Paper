From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sun, 26 Nov 2017 13:19:58 -0500
Subject: [PATCH] AsyncTabCompleteEvent

Let plugins be able to control tab completion of commands and chat async.

This will be useful for frameworks like ACF so we can define async safe completion handlers,
and avoid going to main for tab completions.

Especially useful if you need to query a database in order to obtain the results for tab
completion, such as offline players.

Also adds isCommand and getLocation to the sync TabCompleteEvent

diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 08b59842b8e8c7c577111d552f70648e9a5dd60c..cb6db5357aed0e999244911049196d9970f7ed4f 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -706,10 +706,10 @@ public class ServerGamePacketListenerImpl implements ServerGamePacketListener {
 
     @Override
     public void handleCustomCommandSuggestions(ServerboundCommandSuggestionPacket packetplayintabcomplete) {
-        PacketUtils.ensureRunningOnSameThread(packetplayintabcomplete, this, this.player.getLevel());
+        // PlayerConnectionUtils.ensureMainThread(packetplayintabcomplete, this, this.player.getWorldServer()); // Paper - run this async
         // CraftBukkit start
         if (chatSpamField.addAndGet(this, 1) > 500 && !this.server.getPlayerList().isOp(this.player.getGameProfile())) {
-            this.disconnect(new TranslatableComponent("disconnect.spam", new Object[0]));
+            server.scheduleOnMain(() -> this.disconnect(new TranslatableComponent("disconnect.spam", new Object[0]))); // Paper
             return;
         }
         // CraftBukkit end
@@ -719,12 +719,35 @@ public class ServerGamePacketListenerImpl implements ServerGamePacketListener {
             stringreader.skip();
         }
 
-        ParseResults<CommandSourceStack> parseresults = this.server.getCommands().getDispatcher().parse(stringreader, this.player.createCommandSourceStack());
+        // Paper start - async tab completion
+        com.destroystokyo.paper.event.server.AsyncTabCompleteEvent event;
+        java.util.List<String> completions = new java.util.ArrayList<>();
+        String buffer = packetplayintabcomplete.getCommand();
+        event = new com.destroystokyo.paper.event.server.AsyncTabCompleteEvent(this.getPlayer(), completions,
+                buffer, true, null);
+        event.callEvent();
+        completions = event.isCancelled() ? com.google.common.collect.ImmutableList.of() : event.getCompletions();
+        // If the event isn't handled, we can assume that we have no completions, and so we'll ask the server
+        if (!event.isHandled()) {
+            if (!event.isCancelled()) {
 
-        this.server.getCommands().getDispatcher().getCompletionSuggestions(parseresults).thenAccept((suggestions) -> {
-            if (suggestions.isEmpty()) return; // CraftBukkit - don't send through empty suggestions - prevents [<args>] from showing for plugins with nothing more to offer
-            this.connection.send(new ClientboundCommandSuggestionsPacket(packetplayintabcomplete.getId(), suggestions));
-        });
+                this.server.scheduleOnMain(() -> { // Paper - This needs to be on main
+                    ParseResults<CommandSourceStack> parseresults = this.server.getCommands().getDispatcher().parse(stringreader, this.player.createCommandSourceStack());
+
+                    this.server.getCommands().getDispatcher().getCompletionSuggestions(parseresults).thenAccept((suggestions) -> {
+                        if (suggestions.isEmpty()) return; // CraftBukkit - don't send through empty suggestions - prevents [<args>] from showing for plugins with nothing more to offer
+                        this.connection.send(new ClientboundCommandSuggestionsPacket(packetplayintabcomplete.getId(), suggestions));
+                    });
+                });
+            }
+        } else if (!completions.isEmpty()) {
+            com.mojang.brigadier.suggestion.SuggestionsBuilder builder = new com.mojang.brigadier.suggestion.SuggestionsBuilder(packetplayintabcomplete.getCommand(), stringreader.getTotalLength());
+
+            builder = builder.createOffset(builder.getInput().lastIndexOf(' ') + 1);
+            completions.forEach(builder::suggest);
+            player.connection.send(new ClientboundCommandSuggestionsPacket(packetplayintabcomplete.getId(), builder.buildFuture().join()));
+        }
+        // Paper end - async tab completion
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index d8e49ad2e4834a3911cd1e47f237dd20b8c92313..1147e267119d76ac7c98febe6b3a712277bdb993 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1789,7 +1789,7 @@ public final class CraftServer implements Server {
             offers = tabCompleteChat(player, message);
         }
 
-        TabCompleteEvent tabEvent = new TabCompleteEvent(player, message, offers);
+        TabCompleteEvent tabEvent = new TabCompleteEvent(player, message, offers, message.startsWith("/") || forceCommand, pos != null ? net.minecraft.server.MCUtil.toLocation(((CraftWorld) player.getWorld()).getHandle(), new BlockPos(pos)) : null); // Paper
         getPluginManager().callEvent(tabEvent);
 
         return tabEvent.isCancelled() ? Collections.EMPTY_LIST : tabEvent.getCompletions();
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ConsoleCommandCompleter.java b/src/main/java/org/bukkit/craftbukkit/command/ConsoleCommandCompleter.java
index b49de4f081c9f900cdfc90b9503579d7e707f714..cee291072087c258fd179caa482cfcd336b4f7f9 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ConsoleCommandCompleter.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ConsoleCommandCompleter.java
@@ -26,6 +26,40 @@ public class ConsoleCommandCompleter implements Completer {
     public void complete(LineReader reader, ParsedLine line, List<Candidate> candidates) {
         final CraftServer server = this.server.server;
         final String buffer = line.line();
+        // Paper end
+        // Async Tab Complete
+        com.destroystokyo.paper.event.server.AsyncTabCompleteEvent event;
+        java.util.List<String> completions = new java.util.ArrayList<>();
+        event = new com.destroystokyo.paper.event.server.AsyncTabCompleteEvent(server.getConsoleSender(), completions,
+            buffer, true, null);
+        event.callEvent();
+        completions = event.isCancelled() ? com.google.common.collect.ImmutableList.of() : event.getCompletions();
+
+        if (event.isCancelled() || event.isHandled()) {
+            // Still fire sync event with the provided completions, if someone is listening
+            if (!event.isCancelled() && TabCompleteEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                List<String> finalCompletions = completions;
+                Waitable<List<String>> syncCompletions = new Waitable<List<String>>() {
+                    @Override
+                    protected List<String> evaluate() {
+                        org.bukkit.event.server.TabCompleteEvent syncEvent = new org.bukkit.event.server.TabCompleteEvent(server.getConsoleSender(), buffer, finalCompletions);
+                        return syncEvent.callEvent() ? syncEvent.getCompletions() : com.google.common.collect.ImmutableList.of();
+                    }
+                };
+                server.getServer().processQueue.add(syncCompletions);
+                try {
+                    completions = syncCompletions.get();
+                } catch (InterruptedException | ExecutionException e1) {
+                    e1.printStackTrace();
+                }
+            }
+
+            if (!completions.isEmpty()) {
+                candidates.addAll(completions.stream().map(Candidate::new).collect(java.util.stream.Collectors.toList()));
+            }
+            return;
+        }
+
         // Paper end
         Waitable<List<String>> waitable = new Waitable<List<String>>() {
             @Override
