From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Wed, 6 May 2020 23:30:30 -0400
Subject: [PATCH] Optimize NibbleArray to use pooled buffers

Massively reduces memory allocation of 2048 byte buffers by using
an object pool for these.

Uses lots of advanced new capabilities of the Paper codebase :)

diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLightUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLightUpdatePacket.java
index 924569d4f85c48545d9713ae5181070112483043..b8257ba5d43d5fa56458b190354df92022600c23 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLightUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLightUpdatePacket.java
@@ -1,11 +1,15 @@
 package net.minecraft.network.protocol.game;
 
 import com.google.common.collect.Lists;
+import io.netty.channel.ChannelFuture; // Paper
+
 import java.io.IOException;
 import java.util.List;
 import net.minecraft.core.SectionPos;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.MCUtil;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.LightLayer;
 import net.minecraft.world.level.chunk.DataLayer;
@@ -22,6 +26,35 @@ public class ClientboundLightUpdatePacket implements Packet<ClientGamePacketList
     private List<byte[]> blockUpdates;
     private boolean trustEdges;
 
+    // Paper start
+    java.lang.Runnable cleaner1;
+    java.lang.Runnable cleaner2;
+    java.util.concurrent.atomic.AtomicInteger remainingSends = new java.util.concurrent.atomic.AtomicInteger(0);
+
+    @Override
+    public void onPacketDispatch(ServerPlayer player) {
+        remainingSends.incrementAndGet();
+    }
+
+    @Override
+    public void onPacketDispatchFinish(ServerPlayer player, ChannelFuture future) {
+        if (remainingSends.decrementAndGet() <= 0) {
+            // incase of any race conditions, schedule this delayed
+            MCUtil.scheduleTask(5, () -> {
+                if (remainingSends.get() == 0) {
+                    cleaner1.run();
+                    cleaner2.run();
+                }
+            }, "Light Packet Release");
+        }
+    }
+
+    @Override
+    public boolean hasFinishListener() {
+        return true;
+    }
+
+    // Paper end
     public ClientboundLightUpdatePacket() {
     }
 
@@ -29,8 +62,8 @@ public class ClientboundLightUpdatePacket implements Packet<ClientGamePacketList
         this.x = chunkPos.x;
         this.z = chunkPos.z;
         this.trustEdges = bl;
-        this.skyUpdates = Lists.newArrayList();
-        this.blockUpdates = Lists.newArrayList();
+        this.skyUpdates = Lists.newArrayList();cleaner1 = MCUtil.registerListCleaner(this, this.skyUpdates, DataLayer::releaseBytes); // Paper
+        this.blockUpdates = Lists.newArrayList();cleaner2 = MCUtil.registerListCleaner(this, this.blockUpdates, DataLayer::releaseBytes); // Paper
 
         for(int i = 0; i < 18; ++i) {
             DataLayer dataLayer = levelLightEngine.getLayerListener(LightLayer.SKY).getDataLayerData(SectionPos.of(chunkPos, -1 + i));
@@ -40,7 +73,7 @@ public class ClientboundLightUpdatePacket implements Packet<ClientGamePacketList
                     this.emptySkyYMask |= 1 << i;
                 } else {
                     this.skyYMask |= 1 << i;
-                    this.skyUpdates.add((byte[])dataLayer.getData().clone());
+                    this.skyUpdates.add((byte[])dataLayer.getCloneIfSet()); // Paper
                 }
             }
 
@@ -49,7 +82,7 @@ public class ClientboundLightUpdatePacket implements Packet<ClientGamePacketList
                     this.emptyBlockYMask |= 1 << i;
                 } else {
                     this.blockYMask |= 1 << i;
-                    this.blockUpdates.add((byte[])dataLayer2.getData().clone());
+                    this.blockUpdates.add((byte[])dataLayer2.getCloneIfSet()); // Paper
                 }
             }
         }
@@ -62,14 +95,14 @@ public class ClientboundLightUpdatePacket implements Packet<ClientGamePacketList
         this.trustEdges = bl;
         this.skyYMask = skyLightMask;
         this.blockYMask = blockLightMask;
-        this.skyUpdates = Lists.newArrayList();
-        this.blockUpdates = Lists.newArrayList();
+        this.skyUpdates = Lists.newArrayList();cleaner1 = MCUtil.registerListCleaner(this, this.skyUpdates, DataLayer::releaseBytes); // Paper
+        this.blockUpdates = Lists.newArrayList();cleaner2 = MCUtil.registerListCleaner(this, this.blockUpdates, DataLayer::releaseBytes); // Paper
 
         for(int i = 0; i < 18; ++i) {
             if ((this.skyYMask & 1 << i) != 0) {
                 DataLayer dataLayer = lightProvider.getLayerListener(LightLayer.SKY).getDataLayerData(SectionPos.of(pos, -1 + i));
                 if (dataLayer != null && !dataLayer.isEmpty()) {
-                    this.skyUpdates.add((byte[])dataLayer.getData().clone());
+                    this.skyUpdates.add((byte[])dataLayer.getCloneIfSet()); // Paper
                 } else {
                     this.skyYMask &= ~(1 << i);
                     if (dataLayer != null) {
@@ -81,7 +114,7 @@ public class ClientboundLightUpdatePacket implements Packet<ClientGamePacketList
             if ((this.blockYMask & 1 << i) != 0) {
                 DataLayer dataLayer2 = lightProvider.getLayerListener(LightLayer.BLOCK).getDataLayerData(SectionPos.of(pos, -1 + i));
                 if (dataLayer2 != null && !dataLayer2.isEmpty()) {
-                    this.blockUpdates.add((byte[])dataLayer2.getData().clone());
+                    this.blockUpdates.add((byte[])dataLayer2.getCloneIfSet()); // Paper
                 } else {
                     this.blockYMask &= ~(1 << i);
                     if (dataLayer2 != null) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/DataLayer.java b/src/main/java/net/minecraft/world/level/chunk/DataLayer.java
index fae8b8dc2be5232276e3388a27be2a9f12a490e4..c060b4283199e2e937841a12d3982d4241016f36 100644
--- a/src/main/java/net/minecraft/world/level/chunk/DataLayer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/DataLayer.java
@@ -1,17 +1,77 @@
 package net.minecraft.world.level.chunk;
 
+import com.destroystokyo.paper.util.pooled.PooledObjects; // Paper
+
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import net.minecraft.Util;
+import net.minecraft.server.MCUtil;
 
 public class DataLayer {
 
-    @Nullable
-    protected byte[] data;
+    // Paper start
+    public static byte[] EMPTY_NIBBLE = new byte[2048];
+    private static final int nibbleBucketSizeMultiplier = Integer.getInteger("Paper.nibbleBucketSize", 3072);
+    private static final int maxPoolSize = Integer.getInteger("Paper.maxNibblePoolSize", (int) Math.min(6, Math.max(1, Runtime.getRuntime().maxMemory() / 1024 / 1024 / 1024)) * (nibbleBucketSizeMultiplier * 8));
+    public static final PooledObjects<byte[]> BYTE_2048 = new PooledObjects<>(() -> new byte[2048], maxPoolSize);
+    public static void releaseBytes(byte[] bytes) {
+        if (bytes != null && bytes != EMPTY_NIBBLE && bytes.length == 2048) {
+            System.arraycopy(EMPTY_NIBBLE, 0, bytes, 0, 2048);
+            BYTE_2048.release(bytes);
+        }
+    }
+
+    public DataLayer markPoolSafe(byte[] bytes) {
+        if (bytes != EMPTY_NIBBLE) this.data = bytes;
+        return markPoolSafe();
+    }
+    public DataLayer markPoolSafe() {
+        poolSafe = true;
+        return this;
+    }
+    public byte[] getIfSet() {
+        return this.data != null ? this.data : EMPTY_NIBBLE;
+    }
+    public byte[] getCloneIfSet() {
+        if (data == null) {
+            return EMPTY_NIBBLE;
+        }
+        byte[] ret = BYTE_2048.acquire();
+        System.arraycopy(getIfSet(), 0, ret, 0, 2048);
+        return ret;
+    }
+
+    public DataLayer cloneAndSet(byte[] bytes) {
+        if (bytes != null && bytes != EMPTY_NIBBLE) {
+            this.data = BYTE_2048.acquire();
+            System.arraycopy(bytes, 0, this.data, 0, 2048);
+        }
+        return this;
+    }
+    boolean poolSafe = false;
+    public java.lang.Runnable cleaner;
+    private void registerCleaner() {
+        if (!poolSafe) {
+            cleaner = MCUtil.registerCleaner(this, this.data, DataLayer::releaseBytes);
+        } else {
+            cleaner = MCUtil.once(() -> DataLayer.releaseBytes(this.data));
+        }
+    }
+    // Paper end
+    @Nullable protected byte[] data;
+
 
     public DataLayer() {}
 
     public DataLayer(byte[] abyte) {
+        // Paper start
+        this(abyte, false);
+    }
+    public DataLayer(byte[] abyte, boolean isSafe) {
         this.data = abyte;
+        if (!isSafe) this.data = getCloneIfSet(); // Paper - clone for safety
+        registerCleaner();
+        // Paper end
         if (abyte.length != 2048) {
             throw (IllegalArgumentException) Util.pauseInIde((Throwable) (new IllegalArgumentException("ChunkNibbleArrays should be 2048 bytes not: " + abyte.length)));
         }
@@ -45,7 +105,8 @@ public class DataLayer {
 
     public void set(int index, int value) { // PAIL: private -> public
         if (this.data == null) {
-            this.data = new byte[2048];
+            this.data = BYTE_2048.acquire(); // Paper
+            registerCleaner();// Paper
         }
 
         int k = this.getPosition(index);
@@ -67,13 +128,35 @@ public class DataLayer {
     public byte[] getData() {
         if (this.data == null) {
             this.data = new byte[2048];
+        } else { // Paper start
+            // Accessor may need this object past garbage collection so need to clone it and return pooled value
+            // If we know its safe for pre GC access, use asBytesPoolSafe(). If you just need read, use getIfSet()
+            Runnable cleaner = this.cleaner;
+            if (cleaner != null) {
+                this.data = this.data.clone();
+                cleaner.run(); // release the previously pooled value
+                this.cleaner = null;
+            }
+        }
+        // Paper end
+
+        return this.data;
+    }
+
+    @Nonnull
+    public byte[] asBytesPoolSafe() {
+        if (this.data == null) {
+            this.data = BYTE_2048.acquire(); // Paper
+            registerCleaner(); // Paper
         }
 
+        //noinspection ConstantConditions
         return this.data;
     }
+    // Paper end
 
     public DataLayer copy() {
-        return this.data == null ? new DataLayer() : new DataLayer((byte[]) this.data.clone());
+        return this.data == null ? new DataLayer() : new DataLayer(this.data); // Paper - clone in ctor
     }
 
     public String toString() {
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
index dbd472f50515aa08b79a3994d28ee394c383e2e1..ea8bf4218ea45114366d3a3893317d2b9caecbf2 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
@@ -436,11 +436,11 @@ public class ChunkSerializer {
                 }
 
                 if (nibblearray != null && !nibblearray.isEmpty()) {
-                    nbttagcompound2.putByteArray("BlockLight", nibblearray.getData());
+                    nbttagcompound2.putByteArray("BlockLight", nibblearray.asBytesPoolSafe().clone()); // Paper
                 }
 
                 if (nibblearray1 != null && !nibblearray1.isEmpty()) {
-                    nbttagcompound2.putByteArray("SkyLight", nibblearray1.getData());
+                    nbttagcompound2.putByteArray("SkyLight", nibblearray1.asBytesPoolSafe().clone()); // Paper
                 }
 
                 nbttaglist.add(nbttagcompound2);
diff --git a/src/main/java/net/minecraft/world/level/lighting/DataLayerStorageMap.java b/src/main/java/net/minecraft/world/level/lighting/DataLayerStorageMap.java
index b91bd6a630af85be8f3fd57a50c4b894b21e9b0b..f0c04099e17fce699f32dfb2f8a20034ec0252b2 100644
--- a/src/main/java/net/minecraft/world/level/lighting/DataLayerStorageMap.java
+++ b/src/main/java/net/minecraft/world/level/lighting/DataLayerStorageMap.java
@@ -2,6 +2,7 @@ package net.minecraft.world.level.lighting;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import javax.annotation.Nullable;
+import net.minecraft.server.MCUtil;
 import net.minecraft.world.level.chunk.DataLayer;
 
 public abstract class DataLayerStorageMap<M extends DataLayerStorageMap<M>> {
@@ -33,7 +34,9 @@ public abstract class DataLayerStorageMap<M extends DataLayerStorageMap<M>> {
 
     public void copyDataLayer(long pos) {
         if (this.isVisible) { throw new IllegalStateException("writing to visible data"); } // Paper - avoid copying light data
-        this.map.queueUpdate(pos, ((DataLayer) this.map.getUpdating(pos)).copy()); // Paper - avoid copying light data
+        DataLayer updating = this.map.getUpdating(pos); // Paper - pool nibbles
+        this.map.queueUpdate(pos, new DataLayer().markPoolSafe(updating.getCloneIfSet())); // Paper - avoid copying light data - pool safe clone
+        if (updating.cleaner != null) MCUtil.scheduleTask(2, updating.cleaner, "Light Engine Release"); // Paper - delay clean incase anything holding ref was still using it
         this.clearCache();
     }
 
diff --git a/src/main/java/net/minecraft/world/level/lighting/FlatDataLayer.java b/src/main/java/net/minecraft/world/level/lighting/FlatDataLayer.java
index b12cae2b1b051c1de3c3010692772bb875829bc0..02623141b642996f82a381ccbd406db7d9c04f14 100644
--- a/src/main/java/net/minecraft/world/level/lighting/FlatDataLayer.java
+++ b/src/main/java/net/minecraft/world/level/lighting/FlatDataLayer.java
@@ -9,7 +9,7 @@ public class FlatDataLayer extends DataLayer {
 
     public FlatDataLayer(DataLayer dataLayer, int i) {
         super(128);
-        System.arraycopy(dataLayer.getData(), i * 128, this.data, 0, 128);
+        System.arraycopy(dataLayer.getIfSet(), i * 128, this.data, 0, 128); // Paper
     }
 
     protected int getIndex(int x, int y, int z) {
@@ -17,7 +17,7 @@ public class FlatDataLayer extends DataLayer {
     }
 
     public byte[] getData() {
-        byte[] bs = new byte[2048];
+        byte[] bs = BYTE_2048.acquire(); // Paper
 
         for(int i = 0; i < 16; ++i) {
             System.arraycopy(this.data, 0, bs, i * 128, 128);
diff --git a/src/main/java/net/minecraft/world/level/lighting/LayerLightSectionStorage.java b/src/main/java/net/minecraft/world/level/lighting/LayerLightSectionStorage.java
index 961efc00f40b24be85734f39d1f032fed6982e84..029faf4fd8837344f3472268606b89288faf8e37 100644
--- a/src/main/java/net/minecraft/world/level/lighting/LayerLightSectionStorage.java
+++ b/src/main/java/net/minecraft/world/level/lighting/LayerLightSectionStorage.java
@@ -156,7 +156,7 @@ public abstract class LayerLightSectionStorage<M extends DataLayerStorageMap<M>>
 
     protected DataLayer createDataLayer(long sectionPos) {
         DataLayer dataLayer = this.queuedSections.get(sectionPos);
-        return dataLayer != null ? dataLayer : new DataLayer();
+        return dataLayer != null ? dataLayer : new DataLayer().markPoolSafe(); // Paper
     }
 
     protected void clearQueuedSectionBlocks(LayerLightEngine<?, ?> storage, long sectionPos) {
@@ -315,12 +315,12 @@ public abstract class LayerLightSectionStorage<M extends DataLayerStorageMap<M>>
 
     protected void queueSectionData(long sectionPos, @Nullable DataLayer array, boolean bl) {
         if (array != null) {
-            this.queuedSections.put(sectionPos, array);
+            DataLayer remove = this.queuedSections.put(sectionPos, array); if (remove != null && remove.cleaner != null) remove.cleaner.run(); // Paper - clean up when removed
             if (!bl) {
                 this.untrustedSections.add(sectionPos);
             }
         } else {
-            this.queuedSections.remove(sectionPos);
+            DataLayer remove = this.queuedSections.remove(sectionPos); if (remove != null && remove.cleaner != null) remove.cleaner.run(); // Paper - clean up when removed
         }
 
     }
diff --git a/src/main/java/net/minecraft/world/level/lighting/SkyLightSectionStorage.java b/src/main/java/net/minecraft/world/level/lighting/SkyLightSectionStorage.java
index 60acb305e7f9d074c6dce4368ef5e55b2a66abd5..ce163bc69a830e62b6459fb9e1c8eb462e00ac23 100644
--- a/src/main/java/net/minecraft/world/level/lighting/SkyLightSectionStorage.java
+++ b/src/main/java/net/minecraft/world/level/lighting/SkyLightSectionStorage.java
@@ -151,9 +151,9 @@ public class SkyLightSectionStorage extends LayerLightSectionStorage<SkyLightSec
                     l = SectionPos.offset(l, Direction.UP);
                 }
 
-                return new DataLayer((new FlatDataLayer(dataLayer2, 0)).getData());
+                return new DataLayer().markPoolSafe(new FlatDataLayer(dataLayer2, 0).getData()); // Paper - mark pool use as safe (no auto cleaner)
             } else {
-                return new DataLayer();
+                return new DataLayer().markPoolSafe(); // Paper - mark pool use as safe (no auto cleaner)
             }
         }
     }
@@ -171,7 +171,7 @@ public class SkyLightSectionStorage extends LayerLightSectionStorage<SkyLightSec
                                 this.updatingSectionData.copyDataLayer(l);
                             }
 
-                            Arrays.fill(this.getDataLayer(l, true).getData(), (byte)-1);
+                            Arrays.fill(this.getDataLayer(l, true).asBytesPoolSafe(), (byte)-1); // Paper
                             int j = SectionPos.sectionToBlockCoord(SectionPos.x(l));
                             int k = SectionPos.sectionToBlockCoord(SectionPos.y(l));
                             int m = SectionPos.sectionToBlockCoord(SectionPos.z(l));
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index 6b0eb477de1c1ef2c9e8192278e0d8f9492c77d9..0d4b310352cfd17c2610095eeb414d19f04d83da 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -274,14 +274,14 @@ public class CraftChunk implements Chunk {
                     sectionSkyLights[i] = emptyLight;
                 } else {
                     sectionSkyLights[i] = new byte[2048];
-                    System.arraycopy(skyLightArray.getData(), 0, sectionSkyLights[i], 0, 2048);
+                    System.arraycopy(skyLightArray.getIfSet(), 0, sectionSkyLights[i], 0, 2048); // Paper
                 }
                 DataLayer emitLightArray = lightengine.getLayerListener(LightLayer.BLOCK).getDataLayerData(SectionPos.of(x, i, z));
                 if (emitLightArray == null) {
                     sectionEmitLights[i] = emptyLight;
                 } else {
                     sectionEmitLights[i] = new byte[2048];
-                    System.arraycopy(emitLightArray.getData(), 0, sectionEmitLights[i], 0, 2048);
+                    System.arraycopy(emitLightArray.getIfSet(), 0, sectionEmitLights[i], 0, 2048); // Paper
                 }
             }
         }
