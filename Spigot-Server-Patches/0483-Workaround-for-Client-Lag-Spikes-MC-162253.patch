From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MeFisto94 <MeFisto94@users.noreply.github.com>
Date: Tue, 12 May 2020 23:02:43 +0200
Subject: [PATCH] Workaround for Client Lag Spikes (MC-162253)

When crossing certain chunk boundaries, the client needlessly
calculates light maps for chunk neighbours. In some specific map
configurations, these calculations cause a 500ms+ freeze on the Client.

This patch basically serves as a workaround by sending light maps
to the client, so that it doesn't attempt to calculate them.
This mitigates the frametime impact to a minimum (but it's still there).

diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 9e5cb3b51cfde81a6bba96ae03282ae667cd3855..d9586b9f153185c195c658356724114688f8ea40 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -86,6 +86,7 @@ import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.level.chunk.ImposterProtoChunk;
 import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.chunk.LightChunkGetter;
 import net.minecraft.world.level.chunk.ProtoChunk;
 import net.minecraft.world.level.chunk.UpgradeData;
@@ -2052,9 +2053,68 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
     public final void sendChunk(ServerPlayer entityplayer, Packet<?>[] apacket, LevelChunk chunk) { this.playerLoadedChunk(entityplayer, apacket, chunk); } // Paper - OBFHELPER
     private void playerLoadedChunk(ServerPlayer player, Packet<?>[] packets, LevelChunk chunk) {
         if (packets[0] == null) {
+            // Paper start - add 8 for light fix workaround
+            if (packets.length != 10) { // in case Plugins call sendChunk, resize
+                packets = new Packet[10];
+            }
+            // Paper end
             packets[0] = new ClientboundLevelChunkPacket(chunk, 65535);
             packets[1] = new ClientboundLightUpdatePacket(chunk.getPos(), this.lightEngine, true);
+
+            // Paper start - Fix MC-162253
+            final int lightMask = getLightMask(chunk);
+            int i = 1;
+            for (int x = -1; x <= 1; x++) {
+                for (int z = -1; z <= 1; z++) {
+                    if (x == 0 && z == 0) {
+                        continue;
+                    }
+
+                    ++i;
+
+                    if (!chunk.isNeighbourLoaded(x, z)) {
+                        continue;
+                    }
+
+                    final LevelChunk neighbor = chunk.getRelativeNeighbourIfLoaded(x, z);
+                    final int updateLightMask = lightMask & ~getCeilingLightMask(neighbor);
+
+                    if (updateLightMask == 0) {
+                        continue;
+                    }
+
+                    packets[i] = new ClientboundLightUpdatePacket(new ChunkPos(chunk.getPos().x + x, chunk.getPos().z + z), lightEngine, updateLightMask, 0, true);
+                }
+            }
+        }
+
+        final int viewDistance = playerViewDistanceBroadcastMap.getLastViewDistance(player);
+        final long lastPosition = playerViewDistanceBroadcastMap.getLastCoordinate(player);
+
+        int j = 1;
+        for (int x = -1; x <= 1; x++) {
+            for (int z = -1; z <= 1; z++) {
+                if (x == 0 && z == 0) {
+                    continue;
+                }
+
+                ++j;
+
+                Packet<?> packet = packets[j];
+                if (packet == null) {
+                    continue;
+                }
+
+                final int distX = Math.abs(MCUtil.getCoordinateX(lastPosition) - (chunk.getPos().x + x));
+                final int distZ = Math.abs(MCUtil.getCoordinateZ(lastPosition) - (chunk.getPos().z + z));
+
+                if (Math.max(distX, distZ) > viewDistance) {
+                    continue;
+                }
+                player.connection.send(packet);
+            }
         }
+        // Paper end - Fix MC-162253
 
         player.trackChunk(chunk.getPos(), packets[0], packets[1]);
         DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 832e307f4067ab82b3f1183ea52dd9a9dcb4bc27..0c58a5d170a251ba42ce2d89159f787e64f628f6 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -275,7 +275,7 @@ public class LevelChunk implements ChunkAccess {
 
                     // broadcast
                     Object[] backingSet = inRange.getBackingSet();
-                    Packet[] chunkPackets = new Packet[2];
+                    Packet[] chunkPackets = new Packet[10];
                     for (int index = 0, len = backingSet.length; index < len; ++index) {
                         Object temp = backingSet[index];
                         if (!(temp instanceof ServerPlayer)) {
