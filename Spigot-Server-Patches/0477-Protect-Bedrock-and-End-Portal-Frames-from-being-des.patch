From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Wed, 13 May 2020 23:01:26 -0400
Subject: [PATCH] Protect Bedrock and End Portal/Frames from being destroyed

This fixes exploits that let players destroy bedrock by Pistons, explosions
and Mushrooom/Tree generation.

These blocks are designed to not be broken except by creative players/commands.
So protect them from a multitude of methods of destroying them.

A config is provided if you rather let players use these exploits, and let
them destroy the worlds End Portals and get on top of the nether easy.

diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 6f0c5a2d33001f59e560ec239c0edbd32de84ed8..ac6b291c103c432fdced603674345096326a9efe 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -411,4 +411,17 @@ public class PaperConfig {
     private static void midTickChunkTasks() {
         midTickChunkTasks = getInt("settings.chunk-tasks-per-tick", midTickChunkTasks);
     }
+
+    public static boolean allowBlockPermanentBreakingExploits = false;
+    private static void allowBlockPermanentBreakingExploits() {
+        if (config.contains("allow-perm-block-break-exploits")) {
+            allowBlockPermanentBreakingExploits = config.getBoolean("allow-perm-block-break-exploits", false);
+            config.set("allow-perm-block-break-exploits", null);
+        }
+
+        config.set("settings.unsupported-settings.allow-permanent-block-break-exploits-readme", "This setting controls if players should be able to break bedrock, end portals and other intended to be permanent blocks.");
+        allowBlockPermanentBreakingExploits = getBoolean("settings.unsupported-settings.allow-permanent-block-break-exploits", allowBlockPermanentBreakingExploits);
+
+    }
+
 }
diff --git a/src/main/java/net/minecraft/world/level/Explosion.java b/src/main/java/net/minecraft/world/level/Explosion.java
index c4a92f0413bd3d6bfc1f978dd1a2657fdd13943b..8307abd0eed70d6fd1c4ae65ff558a7df5e2c58d 100644
--- a/src/main/java/net/minecraft/world/level/Explosion.java
+++ b/src/main/java/net/minecraft/world/level/Explosion.java
@@ -152,6 +152,7 @@ public class Explosion {
                         for (float f1 = 0.3F; f > 0.0F; f -= 0.22500001F) {
                             BlockPos blockposition = new BlockPos(d4, d5, d6);
                             BlockState iblockdata = this.level.getBlockState(blockposition);
+                            if (!iblockdata.isDestroyable()) continue; // Paper
                             FluidState fluid = iblockdata.getFluidState(); // Paper
                             Optional<Float> optional = this.damageCalculator.getBlockExplosionResistance(this, this.level, blockposition, iblockdata, fluid);
 
@@ -305,7 +306,7 @@ public class Explosion {
                 BlockState iblockdata = this.level.getBlockState(blockposition);
                 Block block = iblockdata.getBlock();
 
-                if (!iblockdata.isAir()) {
+                if (!iblockdata.isAir() && iblockdata.isDestroyable()) { // Paper
                     BlockPos blockposition1 = blockposition.immutable();
 
                     this.level.getProfiler().push("explosion_blocks");
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 8e7b6140ad62c510321233d0d9105b1e7ca85abe..c0c41e7b2e253e63316bb593a83dc8faff07e5a8 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -423,6 +423,10 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public boolean setBlock(BlockPos blockposition, BlockState iblockdata, int i, int j) {
         // CraftBukkit start - tree generation
         if (this.captureTreeGeneration) {
+            // Paper start
+            BlockState type = getBlockState(blockposition);
+            if (!type.isDestroyable()) return false;
+            // Paper end
             CraftBlockState blockstate = capturedBlockStates.get(blockposition);
             if (blockstate == null) {
                 blockstate = CapturedBlockState.getTreeBlockState(this, blockposition, i);
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index 699266a9b616b961c5e205b875c455bc78e684bf..0ae9527f6b53b268d88a5aa44cf2ade2eedb623c 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -63,6 +63,19 @@ public class Block extends BlockBehaviour implements ItemLike {
     protected final StateDefinition<Block, BlockState> stateDefinition;
     private BlockState defaultBlockState;
     // Paper start
+    public final boolean isDestroyable() {
+        return com.destroystokyo.paper.PaperConfig.allowBlockPermanentBreakingExploits ||
+            this != Blocks.BEDROCK &&
+            this != Blocks.END_PORTAL_FRAME &&
+            this != Blocks.END_PORTAL &&
+            this != Blocks.END_GATEWAY &&
+            this != Blocks.COMMAND_BLOCK &&
+            this != Blocks.REPEATING_COMMAND_BLOCK &&
+            this != Blocks.CHAIN_COMMAND_BLOCK &&
+            this != Blocks.BARRIER &&
+            this != Blocks.STRUCTURE_BLOCK &&
+            this != Blocks.JIGSAW;
+    }
     public co.aikar.timings.Timing timing;
     public co.aikar.timings.Timing getTiming() {
         if (timing == null) {
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
index 4f69b41e74c9c936178b6a1336be5cc3f2ca5fb7..9c927bcaa4e864f4e33cd5a5ae2bd2cce5cd9769 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -193,6 +193,12 @@ public class PistonBaseBlock extends DirectionalBlock {
     @Override
     public boolean triggerEvent(BlockState iblockdata, Level world, BlockPos blockposition, int i, int j) {
         Direction enumdirection = (Direction) iblockdata.getValue(PistonBaseBlock.FACING);
+        // Paper start - prevent retracting when we're facing the wrong way (we were replaced before retraction could occur)
+        Direction directionQueuedAs = Direction.from3DDataValue(j & 7); // Paper - copied from below
+        if (!com.destroystokyo.paper.PaperConfig.allowBlockPermanentBreakingExploits && enumdirection != directionQueuedAs) {
+            return false;
+        }
+        // Paper end - prevent retracting when we're facing the wrong way
 
         if (!world.isClientSide) {
             boolean flag = this.getNeighborSignal(world, blockposition, enumdirection);
@@ -224,7 +230,7 @@ public class PistonBaseBlock extends DirectionalBlock {
             BlockState iblockdata1 = (BlockState) ((BlockState) Blocks.MOVING_PISTON.defaultBlockState().setValue(MovingPistonBlock.FACING, enumdirection)).setValue(MovingPistonBlock.TYPE, this.isSticky ? PistonType.STICKY : PistonType.DEFAULT);
 
             world.setBlock(blockposition, iblockdata1, 20);
-            world.setBlockEntity(blockposition, MovingPistonBlock.newMovingBlockEntity((BlockState) this.defaultBlockState().setValue(PistonBaseBlock.FACING, Direction.from3DDataValue(j & 7)), enumdirection, false, true));
+            world.setBlockEntity(blockposition, MovingPistonBlock.newMovingBlockEntity((BlockState) this.defaultBlockState().setValue(PistonBaseBlock.FACING, Direction.from3DDataValue(j & 7)), enumdirection, false, true)); // Paper - diff on change, j is facing direction - copy this above
             world.blockUpdated(blockposition, iblockdata1.getBlock());
             iblockdata1.updateNeighbourShapes(world, blockposition, 2);
             if (this.isSticky) {
@@ -253,7 +259,14 @@ public class PistonBaseBlock extends DirectionalBlock {
                     }
                 }
             } else {
-                world.removeBlock(blockposition.relative(enumdirection), false);
+                // Paper start - fix headless pistons breaking blocks
+                BlockPos headPos = blockposition.relative(enumdirection);
+                if (com.destroystokyo.paper.PaperConfig.allowBlockPermanentBreakingExploits || world.getBlockState(headPos) == Blocks.PISTON_HEAD.defaultBlockState().setValue(FACING, enumdirection)) { // double check to make sure we're not a headless piston.
+                    world.setAir(headPos, false);
+                } else {
+                    ((ServerLevel)world).getChunkSource().blockChanged(headPos); // ... fix client desync
+                }
+                // Paper end - fix headless pistons breaking blocks
             }
 
             world.playSound((Player) null, blockposition, SoundEvents.PISTON_CONTRACT, SoundSource.BLOCKS, 0.5F, world.random.nextFloat() * 0.15F + 0.6F);
diff --git a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
index fbcc44c258111607568657e52e366d6e6b76ef29..195b1bc0dd734e2327847b9c0639d7105aa174ca 100644
--- a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
+++ b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
@@ -189,7 +189,7 @@ public abstract class BlockBehaviour {
 
     @Deprecated
     public boolean canBeReplaced(BlockState state, BlockPlaceContext context) {
-        return this.material.isReplaceable() && (context.getItemInHand().isEmpty() || context.getItemInHand().getItem() != this.asItem());
+        return this.material.isReplaceable() && (context.getItemInHand().isEmpty() || context.getItemInHand().getItem() != this.asItem()) && (state.isDestroyable() || (context.getPlayer() != null && context.getPlayer().abilities.instabuild)); // Paper
     }
 
     @Deprecated
@@ -393,7 +393,11 @@ public abstract class BlockBehaviour {
         public Block getBlock() {
             return (Block) this.owner;
         }
-
+        // Paper start
+        public final boolean isDestroyable() {
+            return getBlock().isDestroyable();
+        }
+        // Paper end
         public Material getMaterial() {
             return this.material;
         }
@@ -483,7 +487,7 @@ public abstract class BlockBehaviour {
         }
 
         public PushReaction getPistonPushReaction() {
-            return this.getBlock().getPistonPushReaction(this.asState());
+            return !isDestroyable() ? PushReaction.BLOCK : this.getBlock().getPistonPushReaction(this.asState()); // Paper
         }
 
         public boolean isSolidRender(BlockGetter world, BlockPos pos) {
