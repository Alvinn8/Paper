From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <spottedleaf@spottedleaf.dev>
Date: Mon, 6 Apr 2020 17:53:29 -0700
Subject: [PATCH] Remove streams from Mob AI System

The streams hurt performance and allocate tons of garbage, so
replace them with the standard iterator.

Also optimise the stream.anyMatch statement to move to a bitset
where we can replace the call with a single bitwise operation.

diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/Goal.java b/src/main/java/net/minecraft/world/entity/ai/goal/Goal.java
index efb0c5ff751e37d1103fc3208e547bedccc33949..e62b26bb876f10b61fd7359082b11606e848af47 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/Goal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/Goal.java
@@ -1,9 +1,11 @@
 package net.minecraft.world.entity.ai.goal;
 
+import com.destroystokyo.paper.util.set.OptimizedSmallEnumSet; // Paper - remove streams from pathfindergoalselector
 import java.util.EnumSet;
 
 public abstract class Goal {
-    private final EnumSet<Goal.Flag> flags = EnumSet.noneOf(Goal.Flag.class);
+    private final EnumSet<Goal.Flag> flags = EnumSet.noneOf(Goal.Flag.class); // Paper unused, but dummy to prevent plugins from crashing as hard. Theyll need to support paper in a special case if this is super important, but really doesn't seem like it would be.
+    private final OptimizedSmallEnumSet<Flag> goalTypes = new OptimizedSmallEnumSet<>(Goal.Flag.class); // Paper - remove streams from pathfindergoalselector
 
     public abstract boolean canUse();
 
@@ -27,16 +29,20 @@ public abstract class Goal {
     }
 
     public void setFlags(EnumSet<Goal.Flag> controls) {
-        this.flags.clear();
-        this.flags.addAll(controls);
+        // Paper start - remove streams from pathfindergoalselector
+        this.goalTypes.clear();
+        this.goalTypes.addAllUnchecked(controls);
+        // Paper end - remove streams from pathfindergoalselector
     }
 
     public String toString() {
         return this.getClass().getSimpleName();
     }
 
-    public EnumSet<Goal.Flag> getFlags() {
-        return this.flags;
+    // Paper start - remove streams from pathfindergoalselector
+    public com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<Goal.Flag> getGoalTypes() {
+        return this.goalTypes;
+        // Paper end - remove streams from pathfindergoalselector
     }
 
     public static enum Flag {
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
index d96e2319850f2783746c30ff63e7003ecb9bcbe1..4451718ca3499bb57992fdf113568f898f04f714 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
@@ -1,8 +1,10 @@
 package net.minecraft.world.entity.ai.goal;
 
+import com.destroystokyo.paper.util.set.OptimizedSmallEnumSet; // Paper - remove streams from pathfindergoalselector
 import com.google.common.collect.Sets;
 import java.util.EnumMap;
 import java.util.EnumSet;
+import java.util.Iterator; // Paper - remove streams from pathfindergoalselector
 import java.util.Map;
 import java.util.Set;
 import java.util.function.Supplier;
@@ -25,7 +27,8 @@ public class GoalSelector {
     private final Map<Goal.Flag, WrappedGoal> lockedFlags = new EnumMap<>(Goal.Flag.class);
     private final Set<WrappedGoal> availableGoals = Sets.newLinkedHashSet(); private Set<WrappedGoal> getTasks() { return availableGoals; }// Paper - OBFHELPER
     private final Supplier<ProfilerFiller> profiler;
-    private final EnumSet<Goal.Flag> disabledFlags = EnumSet.noneOf(Goal.Flag.class);
+    private final EnumSet<Goal.Flag> disabledFlags = EnumSet.noneOf(Goal.Flag.class); // Paper unused, but dummy to prevent plugins from crashing as hard. Theyll need to support paper in a special case if this is super important, but really doesn't seem like it would be.
+    private final OptimizedSmallEnumSet<Goal.Flag> goalTypes = new OptimizedSmallEnumSet<>(Goal.Flag.class); // Paper - remove streams from pathfindergoalselector
     private int newGoalRate = 3;private int getTickRate() { return newGoalRate; } // Paper - OBFHELPER
     private int curRate;private int getCurRate() { return curRate; } private void incRate() { this.curRate++; } // Paper TODO
 
@@ -57,20 +60,37 @@ public class GoalSelector {
     // Paper end
 
     public void removeGoal(Goal goal) {
-        this.availableGoals.stream().filter((wrappedGoal) -> {
-            return wrappedGoal.getGoal() == goal;
-        }).filter(WrappedGoal::isRunning).forEach(WrappedGoal::stop);
-        this.availableGoals.removeIf((wrappedGoal) -> {
-            return wrappedGoal.getGoal() == goal;
-        });
+        // Paper start - remove streams from pathfindergoalselector
+        for (Iterator<WrappedGoal> iterator = this.availableGoals.iterator(); iterator.hasNext();) {
+            WrappedGoal goalWrapped = iterator.next();
+            if (goalWrapped.getGoal() != goal) {
+                continue;
+            }
+            if (goalWrapped.isRunning()) {
+                goalWrapped.stop();
+            }
+            iterator.remove();
+        }
+        // Paper end - remove streams from pathfindergoalselector
     }
 
+    private static final Goal.Flag[] PATHFINDER_GOAL_TYPES = Goal.Flag.values(); // Paper - remove streams from pathfindergoalselector
+
     public void tick() {
         ProfilerFiller profilerFiller = this.profiler.get();
         profilerFiller.push("goalCleanup");
-        this.getRunningGoals().filter((wrappedGoal) -> {
-            return !wrappedGoal.isRunning() || wrappedGoal.getFlags().stream().anyMatch(this.disabledFlags::contains) || !wrappedGoal.canContinueToUse();
-        }).forEach(Goal::stop);
+        // Paper start - remove streams from pathfindergoalselector
+        for (Iterator<WrappedGoal> iterator = this.availableGoals.iterator(); iterator.hasNext();) {
+            WrappedGoal wrappedGoal = iterator.next();
+            if (!wrappedGoal.isRunning()) {
+                continue;
+            }
+            if (!this.goalTypes.hasCommonElements(wrappedGoal.getGoalTypes()) && wrappedGoal.canContinueToUse()) {
+                continue;
+            }
+            wrappedGoal.stop();
+        }
+        // Paper end - remove streams from pathfindergoalselector
         this.lockedFlags.forEach((flag, wrappedGoal) -> {
             if (!wrappedGoal.isRunning()) {
                 this.lockedFlags.remove(flag);
@@ -79,25 +99,58 @@ public class GoalSelector {
         });
         profilerFiller.pop();
         profilerFiller.push("goalUpdate");
-        this.availableGoals.stream().filter((wrappedGoal) -> {
-            return !wrappedGoal.isRunning();
-        }).filter((wrappedGoal) -> {
-            return wrappedGoal.getFlags().stream().noneMatch(this.disabledFlags::contains);
-        }).filter((wrappedGoal) -> {
-            return wrappedGoal.getFlags().stream().allMatch((flag) -> {
-                return this.lockedFlags.getOrDefault(flag, NO_GOAL).canBeReplacedBy(wrappedGoal);
-            });
-        }).filter(WrappedGoal::canUse).forEach((wrappedGoal) -> {
-            wrappedGoal.getFlags().forEach((flag) -> {
-                WrappedGoal wrappedGoal2 = this.lockedFlags.getOrDefault(flag, NO_GOAL);
-                wrappedGoal2.stop();
-                this.lockedFlags.put(flag, wrappedGoal);
-            });
+        // Paper start - remove streams from pathfindergoalselector
+        goal_update_loop: for (Iterator<WrappedGoal> iterator = this.availableGoals.iterator(); iterator.hasNext();) {
+            WrappedGoal wrappedGoal = iterator.next();
+            if (wrappedGoal.isRunning()) {
+                continue;
+            }
+
+            OptimizedSmallEnumSet<Goal.Flag> wrappedGoalSet = wrappedGoal.getGoalTypes();
+
+            if (this.goalTypes.hasCommonElements(wrappedGoalSet)) {
+                continue;
+            }
+
+            long iterator1 = wrappedGoalSet.getBackingSet();
+            int wrappedGoalSize = wrappedGoalSet.size();
+            for (int i = 0; i < wrappedGoalSize; ++i) {
+                Goal.Flag type = PATHFINDER_GOAL_TYPES[Long.numberOfTrailingZeros(iterator1)];
+                iterator1 ^= com.destroystokyo.paper.util.math.IntegerUtil.getTrailingBit(iterator1);
+                WrappedGoal wrapped = this.lockedFlags.getOrDefault(type, GoalSelector.NO_GOAL);
+                if (!wrapped.canBeReplacedBy(wrappedGoal)) {
+                    continue goal_update_loop;
+                }
+            }
+
+            if (!wrappedGoal.canUse()) {
+                continue;
+            }
+
+            iterator1 = wrappedGoalSet.getBackingSet();
+            wrappedGoalSize = wrappedGoalSet.size();
+            for (int i = 0; i < wrappedGoalSize; ++i) {
+                Goal.Flag type = PATHFINDER_GOAL_TYPES[Long.numberOfTrailingZeros(iterator1)];
+                iterator1 ^= com.destroystokyo.paper.util.math.IntegerUtil.getTrailingBit(iterator1);
+                WrappedGoal wrapped = this.lockedFlags.getOrDefault(type, GoalSelector.NO_GOAL);
+
+                wrapped.stop();
+                this.lockedFlags.put(type, wrappedGoal);
+            }
+
             wrappedGoal.start();
-        });
+        }
+        // Paper end - remove streams from pathfindergoalselector
         profilerFiller.pop();
         profilerFiller.push("goalTick");
-        this.getRunningGoals().forEach(WrappedGoal::tick);
+        // Paper start - remove streams from pathfindergoalselector
+        for (Iterator<WrappedGoal> iterator = this.availableGoals.iterator(); iterator.hasNext();) {
+            WrappedGoal wrappedGoal = iterator.next();
+            if (wrappedGoal.isRunning()) {
+                wrappedGoal.tick();
+            }
+        }
+        // Paper end - remove streams from pathfindergoalselector
         profilerFiller.pop();
     }
 
@@ -106,11 +159,11 @@ public class GoalSelector {
     }
 
     public void disableControlFlag(Goal.Flag control) {
-        this.disabledFlags.add(control);
+        this.goalTypes.addUnchecked(control); // Paper - remove streams from pathfindergoalselector
     }
 
     public void enableControlFlag(Goal.Flag control) {
-        this.disabledFlags.remove(control);
+        this.goalTypes.removeUnchecked(control); // Paper - remove streams from pathfindergoalselector
     }
 
     public void setControlFlag(Goal.Flag control, boolean enabled) {
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/WrappedGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/WrappedGoal.java
index 9d7ea91983753f7c15ff8d19d74511c03c09a5d6..d35ff3e6e9e4b50d53f7cef16bdb4e137cf9df1c 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/WrappedGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/WrappedGoal.java
@@ -51,11 +51,12 @@ public class WrappedGoal extends Goal {
         this.goal.setFlags(controls);
     }
 
-    public EnumSet<Goal.Flag> getFlags() {
-        return this.goal.getFlags();
+    // Paper start - remove streams from pathfindergoalselector
+    public com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<Goal.Flag> getGoalTypes() {
+        return this.goal.getGoalTypes();
+        // Paper end - remove streams from pathfindergoalselector
     }
 
-    public boolean isRunning() { return this.isRunning(); } // Paper - OBFHELPER
     public boolean isRunning() {
         return this.isRunning;
     }
