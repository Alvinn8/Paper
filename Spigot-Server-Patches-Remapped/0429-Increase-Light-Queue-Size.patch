From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Wed, 8 Apr 2020 21:24:05 -0400
Subject: [PATCH] Increase Light Queue Size

Wiz mentioned that large WorldEdit operations cause light to run on
main thread. The queue was small, set to 5.. this bumps it to 20
but makes it configurable per-world.

The main risk of increasing this higher is during shutdown, some
queued light updates may be lost because mojang did not flush the
light engine on shutdown...

The queue size only puts a cap on max loss, doesn't solve that problem.

diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 1b49c214998a5a9b424472df040d634d9fcc0c4a..d7e22e1bf886800adbe8ed7baa3349e5d2ee1818 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -609,4 +609,9 @@ public class PaperWorldConfig {
     private void zombieVillagerInfectionChance() {
         zombieVillagerInfectionChance = getDouble("zombie-villager-infection-chance", zombieVillagerInfectionChance);
     }
+
+    public int lightQueueSize = 20;
+    private void lightQueueSize() {
+        lightQueueSize = getInt("light-queue-size", lightQueueSize);
+    }
 }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 1757f8f7f32f01a17c7b6adceda427a64973a344..7d4f78469eaa05122c3b1a5b006150e35d9c6dd5 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -759,7 +759,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.executeModerately();
         // CraftBukkit end
         worldloadlistener.stop();
-        chunkproviderserver.getLightEngine().setTaskPerBatch(5);
+        chunkproviderserver.getLightEngine().setTaskPerBatch(worldserver.paperConfig.lightQueueSize); // Paper - increase light queue size
         // CraftBukkit start
         // this.bc();
         worldserver.setSpawnSettings(this.isSpawningMonsters(), this.isSpawningAnimals());
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index b20f390df738aab7a0db23a42261f6b406ec4e11..0ab2ca3f0a52a3b120a6fb07495417f242e80cb7 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -106,7 +106,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public static final int MAX_CHUNK_DISTANCE = 33 + ChunkStatus.maxDistance();
     // Paper start - faster copying
     public final Long2ObjectLinkedOpenHashMap<ChunkHolder> updatingChunkMap = new com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<>(); // Paper - faster copying
-    public final Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunkMap = new net.minecraft.server.level.ChunkMap.ProtectedVisibleChunksMap(); // Paper - faster copying
+    public final Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunkMap = new ProtectedVisibleChunksMap(); // Paper - faster copying
 
     private class ProtectedVisibleChunksMap extends com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<ChunkHolder> {
         @Override
@@ -310,7 +310,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         } finally {
             this.isIterating = prev;
             if (!this.isIterating && this.hasPendingVisibleUpdate) {
-                ((net.minecraft.server.level.ChunkMap.ProtectedVisibleChunksMap)this.visibleChunkMap).copyFrom(this.pendingVisibleChunks);
+                ((ProtectedVisibleChunksMap)this.visibleChunkMap).copyFrom(this.pendingVisibleChunks);
                 this.pendingVisibleChunks.clear();
                 this.hasPendingVisibleUpdate = false;
             }
@@ -323,7 +323,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             synchronized (this.visibleChunkMap) {
                 if (DEBUG_ASYNC_VISIBLE_CHUNKS) new Throwable("Async getVisibleChunks").printStackTrace();
                 if (this.visibleChunksClone == null) {
-                    this.visibleChunksClone = this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.clone() : ((net.minecraft.server.level.ChunkMap.ProtectedVisibleChunksMap)this.visibleChunkMap).clone();
+                    this.visibleChunksClone = this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.clone() : ((ProtectedVisibleChunksMap)this.visibleChunkMap).clone();
                 }
                 return this.visibleChunksClone;
             }
@@ -336,10 +336,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper start - mt safe get
         if (Thread.currentThread() != this.level.thread) {
             synchronized (this.visibleChunkMap) {
-                return (ChunkHolder) (this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.get(pos) : ((net.minecraft.server.level.ChunkMap.ProtectedVisibleChunksMap)this.visibleChunkMap).safeGet(pos));
+                return (ChunkHolder) (this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.get(pos) : ((ProtectedVisibleChunksMap)this.visibleChunkMap).safeGet(pos));
             }
         }
-        return (ChunkHolder) (this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.get(pos) : ((net.minecraft.server.level.ChunkMap.ProtectedVisibleChunksMap)this.visibleChunkMap).safeGet(pos));
+        return (ChunkHolder) (this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.get(pos) : ((ProtectedVisibleChunksMap)this.visibleChunkMap).safeGet(pos));
         // Paper end
     }
 
@@ -737,7 +737,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 } else {
                     hasPendingVisibleUpdate = false;
                     this.pendingVisibleChunks.clear();
-                    ((net.minecraft.server.level.ChunkMap.ProtectedVisibleChunksMap)this.visibleChunkMap).copyFrom((com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<ChunkHolder>)this.updatingChunkMap);
+                    ((ProtectedVisibleChunksMap)this.visibleChunkMap).copyFrom((com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<ChunkHolder>)this.updatingChunkMap);
                     this.visibleChunksClone = null;
                 }
             }
