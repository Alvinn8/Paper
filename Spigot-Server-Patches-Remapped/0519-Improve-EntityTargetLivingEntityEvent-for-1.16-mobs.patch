From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Fri, 3 Jul 2020 15:03:33 -0700
Subject: [PATCH] Improve EntityTargetLivingEntityEvent for 1.16 mobs

CraftBukkit has a bug in their implementation and is incorrectly handling forget
Also adds more target reasons for why it forgot target.

diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/StopAttackingIfTargetInvalid.java b/src/main/java/net/minecraft/world/entity/ai/behavior/StopAttackingIfTargetInvalid.java
index 0f389f7fa0bac30464d1aec78b9dac20292af94a..bc5d279d0f98cee8fa9edf826f77e4a12eaa23fc 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/StopAttackingIfTargetInvalid.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/StopAttackingIfTargetInvalid.java
@@ -32,15 +32,15 @@ public class StopAttackingIfTargetInvalid<E extends Mob> extends Behavior<E> {
 
     protected void start(ServerLevel worldserver, E e0, long i) {
         if (isTiredOfTryingToReachTarget((LivingEntity) e0)) {
-            this.clearAttackTarget(e0);
+            this.d(e0, org.bukkit.event.entity.EntityTargetEvent.TargetReason.FORGOT_TARGET); // Paper
         } else if (this.isCurrentTargetDeadOrRemoved(e0)) {
-            this.clearAttackTarget(e0);
+            this.d(e0, org.bukkit.event.entity.EntityTargetEvent.TargetReason.TARGET_DIED); // Paper
         } else if (this.isCurrentTargetInDifferentLevel(e0)) {
-            this.clearAttackTarget(e0);
+            this.d(e0, org.bukkit.event.entity.EntityTargetEvent.TargetReason.TARGET_OTHER_LEVEL); // Paper
         } else if (!EntitySelector.ATTACK_ALLOWED.test(this.getAttackTarget(e0))) {
-            this.clearAttackTarget(e0);
+            this.d(e0, org.bukkit.event.entity.EntityTargetEvent.TargetReason.TARGET_INVALID); // Paper
         } else if (this.stopAttackingWhen.test(this.getAttackTarget(e0))) {
-            this.clearAttackTarget(e0);
+            this.d(e0, org.bukkit.event.entity.EntityTargetEvent.TargetReason.TARGET_INVALID); // Paper
         }
     }
 
@@ -64,18 +64,21 @@ public class StopAttackingIfTargetInvalid<E extends Mob> extends Behavior<E> {
         return optional.isPresent() && !((LivingEntity) optional.get()).isAlive();
     }
 
-    private void clearAttackTarget(E entity) {
+    private void d(E e0, EntityTargetEvent.TargetReason reason) {
         // CraftBukkit start
-        LivingEntity old = entity.getBrain().getMemory(MemoryModuleType.ATTACK_TARGET).orElse(null);
-        EntityTargetEvent event = CraftEventFactory.callEntityTargetLivingEvent(entity, null, (old != null && !old.isAlive()) ? EntityTargetEvent.TargetReason.TARGET_DIED : EntityTargetEvent.TargetReason.FORGOT_TARGET);
+        // Paper start - fix this event
+        //EntityLiving old = e0.getBehaviorController().getMemory(MemoryModuleType.ATTACK_TARGET).orElse(null);
+        EntityTargetEvent event = CraftEventFactory.callEntityTargetLivingEvent(e0, null, reason);
         if (event.isCancelled()) {
             return;
         }
-        if (event.getTarget() != null) {
-            entity.getBrain().setMemory(MemoryModuleType.ATTACK_TARGET, ((CraftLivingEntity) event.getTarget()).getHandle());
+        // comment out, bad logic - bad
+        /*if (event.getTarget() != null) {
+            e0.getBehaviorController().setMemory(MemoryModuleType.ATTACK_TARGET, ((CraftLivingEntity) event.getTarget()).getHandle());
             return;
-        }
+        }*/
+        // Paper end
         // CraftBukkit end
-        entity.getBrain().eraseMemory(MemoryModuleType.ATTACK_TARGET);
+        e0.getBrain().eraseMemory(MemoryModuleType.ATTACK_TARGET);
     }
 }
