From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Mon, 10 Sep 2018 23:56:36 -0400
Subject: [PATCH] Prevent Mob AI Rules from Loading Chunks


diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/RemoveBlockGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/RemoveBlockGoal.java
index 2ecae507b09f540c649976c33a8c561aadf97723..5efa9f06e8adcd0f8fb0743fc0fc0a6d9b949779 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/RemoveBlockGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/RemoveBlockGoal.java
@@ -17,7 +17,6 @@ import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.LevelReader;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.chunk.ChunkAccess;
-import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.phys.Vec3;
 // CraftBukkit start
 import org.bukkit.craftbukkit.block.CraftBlock;
@@ -29,11 +28,13 @@ public class RemoveBlockGoal extends MoveToBlockGoal {
     private final Block blockToRemove;
     private final Mob removerMob;
     private int ticksSinceReachedGoal;
+    private Level world; // Paper
 
     public RemoveBlockGoal(Block targetBlock, PathfinderMob mob, double speed, int maxYDifference) {
         super(mob, speed, 24, maxYDifference);
         this.blockToRemove = targetBlock;
         this.removerMob = mob;
+        this.world = mob.level; // Paper
     }
 
     @Override
@@ -131,7 +132,9 @@ public class RemoveBlockGoal extends MoveToBlockGoal {
 
     @Nullable
     private BlockPos getPosWithBlock(BlockPos pos, BlockGetter world) {
-        if (world.getBlockState(pos).is(this.blockToRemove)) {
+        Block block = world.getBlockIfLoaded(pos); // Paper
+        if (block == null) return null; // Paper
+        if (block.is(this.blockToRemove)) { // Paper
             return pos;
         } else {
             BlockPos[] ablockposition = new BlockPos[]{pos.below(), pos.west(), pos.east(), pos.north(), pos.south(), pos.below().below()};
@@ -141,7 +144,7 @@ public class RemoveBlockGoal extends MoveToBlockGoal {
             for (int j = 0; j < i; ++j) {
                 BlockPos blockposition1 = ablockposition1[j];
 
-                if (world.getBlockState(blockposition1).is(this.blockToRemove)) {
+                if (world.getBlockIfLoaded(blockposition1).is(this.blockToRemove)) { // Paper
                     return blockposition1;
                 }
             }
@@ -152,7 +155,7 @@ public class RemoveBlockGoal extends MoveToBlockGoal {
 
     @Override
     protected boolean isValidTarget(LevelReader iworldreader, BlockPos blockposition) {
-        ChunkAccess ichunkaccess = iworldreader.getChunk(blockposition.getX() >> 4, blockposition.getZ() >> 4, ChunkStatus.FULL, false);
+        ChunkAccess ichunkaccess = iworldreader.getChunkIfLoadedImmediately(blockposition.getX() >> 4, blockposition.getZ() >> 4); // Paper
 
         return ichunkaccess == null ? false : ichunkaccess.getBlockState(blockposition).is(this.blockToRemove) && ichunkaccess.getBlockState(blockposition.above()).isAir() && ichunkaccess.getBlockState(blockposition.above(2)).isAir();
     }
diff --git a/src/main/java/net/minecraft/world/entity/ai/util/RandomPos.java b/src/main/java/net/minecraft/world/entity/ai/util/RandomPos.java
index c3981d244f0b6c21416cb04dcdfc813105686c5d..e871ee5a20185f132462836e98e2dfe1b226ae35 100644
--- a/src/main/java/net/minecraft/world/entity/ai/util/RandomPos.java
+++ b/src/main/java/net/minecraft/world/entity/ai/util/RandomPos.java
@@ -13,6 +13,7 @@ import net.minecraft.util.Mth;
 import net.minecraft.world.entity.PathfinderMob;
 import net.minecraft.world.entity.ai.navigation.PathNavigation;
 import net.minecraft.world.level.BlockGetter;
+import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.pathfinder.BlockPathTypes;
 import net.minecraft.world.level.pathfinder.WalkNodeEvaluator;
 import net.minecraft.world.phys.Vec3;
@@ -128,6 +129,7 @@ public class RandomPos {
                 }
 
                 blockposition2 = new BlockPos((double) k1 + mob.getX(), (double) l1 + mob.getY(), (double) i2 + mob.getZ());
+                if (!mob.level.hasChunkAt(blockposition2)) continue; // Paper
                 if (blockposition2.getY() >= 0 && blockposition2.getY() <= mob.level.getMaxBuildHeight() && (!flag3 || mob.isWithinRestriction(blockposition2)) && (!validPositionsOnly || navigationabstract.isStableDestination(blockposition2))) {
                     if (aboveGround) {
                         blockposition2 = moveUpToAboveSolid(blockposition2, random.nextInt(distanceAboveGroundRange + 1) + minDistanceAboveGround, mob.level.getMaxBuildHeight(), (blockposition3) -> {
@@ -135,7 +137,8 @@ public class RandomPos {
                         });
                     }
 
-                    if (notInWater || !mob.level.getFluidState(blockposition2).is((Tag) FluidTags.WATER)) {
+                    FluidState fluid = mob.level.getFluidIfLoaded(blockposition2); // Paper
+                    if (notInWater || (fluid != null && !fluid.is((Tag) FluidTags.WATER))) { // Paper
                         BlockPathTypes pathtype = WalkNodeEvaluator.getBlockPathTypeStatic((BlockGetter) mob.level, blockposition2.mutable());
 
                         if (mob.getPathfindingMalus(pathtype) == 0.0F) {
