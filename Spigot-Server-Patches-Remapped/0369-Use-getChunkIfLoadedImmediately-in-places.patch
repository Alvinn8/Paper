From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Mon, 8 Jul 2019 00:13:36 -0700
Subject: [PATCH] Use getChunkIfLoadedImmediately in places

This prevents us from hitting chunk loads for chunks at or less-than
ticket level 33 (yes getChunkIfLoaded will actually perform a chunk
load in that case).

diff --git a/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java b/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
index d0826f477971c8999ba3d3ae8bb06c4878c1481a..a630a84b60b4517e3bc330d4983b914bd064efa4 100644
--- a/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
+++ b/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
@@ -6,7 +6,7 @@ import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.storage.RegionFile;
 import org.apache.logging.log4j.Logger;
-import com.destroystokyo.paper.io.PaperFileIOThread.GeneralTask;
+
 import java.io.IOException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentHashMap;
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 0af2ad21aeff5e26a84f06c360d079d05a2d828b..f9d337496c2648e86a6c01ca5e7fb455242e635e 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -201,7 +201,7 @@ public class ServerLevel extends net.minecraft.world.level.Level implements Worl
     }
 
     @Override public LevelChunk getChunkIfLoaded(int x, int z) { // Paper - this was added in world too but keeping here for NMS ABI
-        return this.chunkSource.getChunk(x, z, false);
+        return this.chunkSource.getChunkAtIfLoadedImmediately(x, z); // Paper
     }
 
     // Paper start - Asynchronous IO
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index ebfbf3648b9423b68f64a0d0a455ed03c81ea36e..6a7b1ea53655e4308e505f5092d002f16cafd47e 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -1228,7 +1228,7 @@ public class ServerGamePacketListenerImpl implements ServerGamePacketListener {
                                 speed = player.abilities.walkingSpeed * 10f;
                             }
                             // Paper start - Prevent moving into unloaded chunks
-                            if (player.level.paperConfig.preventMovingIntoUnloadedChunks && (this.player.getX() != toX || this.player.getZ() != toZ) && !worldserver.hasChunk((int) Math.floor(toX) >> 4, (int) Math.floor(toZ) >> 4)) {
+                            if (player.level.paperConfig.preventMovingIntoUnloadedChunks && (this.player.getX() != toX || this.player.getZ() != toZ) && worldserver.getChunkIfLoadedImmediately((int) Math.floor(toX) >> 4, (int) Math.floor(toZ) >> 4) == null) { // Paper - use getIfLoadedImmediately
                                 this.internalTeleport(this.player.getX(), this.player.getY(), this.player.getZ(), this.player.yRot, this.player.xRot, Collections.emptySet());
                                 return;
                             }
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 0742c29b026e16e37f820f8a37521bb79600d5e4..8c541b570fb055ce11573f85daab182d86e5011d 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -165,6 +165,13 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         return (CraftServer) Bukkit.getServer();
     }
 
+    // Paper start
+    @Override
+    public boolean hasChunk(int chunkX, int chunkZ) {
+        return ((ServerLevel)this).getChunkIfLoaded(chunkX, chunkZ) != null;
+    }
+    // Paper end
+
     public ResourceKey<DimensionType> getTypeKey() {
         return typeKey;
     }
@@ -1063,14 +1070,14 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     }
 
     public boolean isLoaded(BlockPos pos) {
-        return isOutsideBuildHeight(pos) ? false : this.getChunkSource().hasChunk(pos.getX() >> 4, pos.getZ() >> 4);
+        return isOutsideBuildHeight(pos) ? false : hasChunk(pos.getX() >> 4, pos.getZ() >> 4); // Paper
     }
 
     public boolean loadedAndEntityCanStandOnFace(BlockPos pos, Entity entity, Direction direction) {
         if (isOutsideBuildHeight(pos)) {
             return false;
         } else {
-            ChunkAccess ichunkaccess = this.getChunk(pos.getX() >> 4, pos.getZ() >> 4, ChunkStatus.FULL, false);
+            ChunkAccess ichunkaccess = this.getChunkIfLoadedImmediately(pos.getX() >> 4, pos.getZ() >> 4); // Paper
 
             return ichunkaccess == null ? false : ichunkaccess.getBlockState(pos).entityCanStandOnFace((BlockGetter) this, pos, entity, direction);
         }
@@ -1191,7 +1198,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
 
         for (int i1 = i; i1 < j; ++i1) {
             for (int j1 = k; j1 < l; ++j1) {
-                LevelChunk chunk = ichunkprovider.getChunkNow(i1, j1);
+                LevelChunk chunk = (LevelChunk)this.getChunkIfLoadedImmediately(i1, j1); // Paper
 
                 if (chunk != null) {
                     chunk.getEntitiesOfClass(oclass, axisalignedbb, list, predicate);
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
index 639dffd9ca4e6802c1525f30e033ee05c5c2f389..1667322157716200c19069f49f2bb35c5a60b6a6 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
@@ -83,12 +83,12 @@ public class ChunkSerializer {
     }
 
     public static ProtoChunk read(ServerLevel world, StructureManager structureManager, PoiManager poiStorage, ChunkPos pos, CompoundTag tag) {
-        net.minecraft.world.level.chunk.storage.ChunkSerializer.InProgressChunkHolder holder = loadChunk(world, structureManager, poiStorage, pos, tag, true);
+        InProgressChunkHolder holder = loadChunk(world, structureManager, poiStorage, pos, tag, true);
         holder.tasks.forEach(Runnable::run);
         return holder.protoChunk;
     }
 
-    public static net.minecraft.world.level.chunk.storage.ChunkSerializer.InProgressChunkHolder loadChunk(ServerLevel worldserver, StructureManager definedstructuremanager, PoiManager villageplace, ChunkPos chunkcoordintpair, CompoundTag nbttagcompound, boolean distinguish) {
+    public static InProgressChunkHolder loadChunk(ServerLevel worldserver, StructureManager definedstructuremanager, PoiManager villageplace, ChunkPos chunkcoordintpair, CompoundTag nbttagcompound, boolean distinguish) {
         ArrayDeque<Runnable> tasksToExecuteOnMain = new ArrayDeque<>();
         // Paper end
         ChunkGenerator chunkgenerator = worldserver.getChunkSource().getGenerator();
@@ -265,7 +265,7 @@ public class ChunkSerializer {
         }
 
         if (chunkstatus_type == ChunkStatus.ChunkType.LEVELCHUNK) {
-            return new net.minecraft.world.level.chunk.storage.ChunkSerializer.InProgressChunkHolder(new ImposterProtoChunk((LevelChunk) object), tasksToExecuteOnMain); // Paper - Async chunk loading
+            return new InProgressChunkHolder(new ImposterProtoChunk((LevelChunk) object), tasksToExecuteOnMain); // Paper - Async chunk loading
         } else {
             ProtoChunk protochunk1 = (ProtoChunk) object;
 
@@ -304,7 +304,7 @@ public class ChunkSerializer {
                 protochunk1.setCarvingMask(worldgenstage_features, BitSet.valueOf(nbttagcompound5.getByteArray(s1)));
             }
 
-            return new net.minecraft.world.level.chunk.storage.ChunkSerializer.InProgressChunkHolder(protochunk1, tasksToExecuteOnMain); // Paper - Async chunk loading
+            return new InProgressChunkHolder(protochunk1, tasksToExecuteOnMain); // Paper - Async chunk loading
         }
     }
 
@@ -329,7 +329,7 @@ public class ChunkSerializer {
     }
 
     // must be called sync
-    public static net.minecraft.world.level.chunk.storage.ChunkSerializer.AsyncSaveData getAsyncSaveData(ServerLevel world, ChunkAccess chunk) {
+    public static AsyncSaveData getAsyncSaveData(ServerLevel world, ChunkAccess chunk) {
         org.spigotmc.AsyncCatcher.catchOp("preparation of chunk data for async save");
         ChunkPos chunkPos = chunk.getPos();
 
@@ -373,13 +373,13 @@ public class ChunkSerializer {
             fluidTickListSerialized = world.getLiquidTicks().save(chunkPos);
         }
 
-        return new net.minecraft.world.level.chunk.storage.ChunkSerializer.AsyncSaveData(blockLight, skyLight, blockTickListSerialized, fluidTickListSerialized, world.getGameTime());
+        return new AsyncSaveData(blockLight, skyLight, blockTickListSerialized, fluidTickListSerialized, world.getGameTime());
     }
 
     public static CompoundTag write(ServerLevel world, ChunkAccess chunk) {
         return saveChunk(world, chunk, null);
     }
-    public static CompoundTag saveChunk(ServerLevel worldserver, ChunkAccess ichunkaccess, net.minecraft.world.level.chunk.storage.ChunkSerializer.AsyncSaveData asyncsavedata) {
+    public static CompoundTag saveChunk(ServerLevel worldserver, ChunkAccess ichunkaccess, AsyncSaveData asyncsavedata) {
         // Paper end
         ChunkPos chunkcoordintpair = ichunkaccess.getPos();
         CompoundTag nbttagcompound = new CompoundTag();
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index 9dedd44aebb17f18985e1666e09ce863c7dd1a16..38d638e137cb4c0549206aa849ebe0b23ba7e58e 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -142,9 +142,10 @@ public class ActivationRange
             {
                 for ( int j1 = k; j1 <= l; ++j1 )
                 {
-                    if ( world.getWorld().isChunkLoaded( i1, j1 ) )
+                    LevelChunk chunk = (LevelChunk) world.getChunkIfLoadedImmediately( i1, j1 );
+                    if ( chunk != null )
                     {
-                        activateChunkEntities( world.getChunk( i1, j1 ) );
+                        activateChunkEntities( chunk );
                     }
                 }
             }
